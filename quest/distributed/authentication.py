"""
Programmer's Quest! authentication code for allowing clients access to the Astron cluster instance using the PlayFab BaaS system provided by Azure's Gaming Stack
"""

from quest.distributed import objects, constants
from quest.engine import runtime

from playfab import PlayFabClientAPI, PlayFabServerAPI
from direct.distributed.PyDatagram import PyDatagram
from direct.distributed import MsgTypes

import dataclasses
import enum

#----------------------------------------------------------------------------------------------------------------------------------------------------------------------#

class QuestInternalAuthResults(enum.IntEnum):
    """
    Represents all understood internal auth result error codes
    """

    QIAR_SUCCESS = 200
    QIAR_INTERNAL_ERROR = 1500

#----------------------------------------------------------------------------------------------------------------------------------------------------------------------#

@dataclasses.dataclass
class QuestAccount(objects.QuestDistributedObject):
    """
    Stub object to fulfill the requirements of the DC system. This is used internally to bridge the PlayFab account details to the details stored
    within the Astron cluster database.
    """

@dataclasses.dataclass
class QuestAccountAI(objects.QuestDistributedObjectAI):
    """
    Stub object to fulfill the requirements of the DC system. This is used internally to bridge the PlayFab account details to the details stored
    within the Astron cluster database.
    """

@dataclasses.dataclass
class QuestAccountUD(objects.QuestDistributedObjectUD):
    """
    Stub object to fulfill the requirements of the DC system. This is used internally to bridge the PlayFab account details to the details stored
    within the Astron cluster database.
    """

    playfab_account_id: str

#----------------------------------------------------------------------------------------------------------------------------------------------------------------------#

class QuestLoginManager(objects.QuestDistributedObjectGlobal):
    """
    Client side DOG instance of the QuestLoginManager used to authenticate with the Astron cluster and gain entry to the game world.
    """

    def __init__(self, cr):
        super().__init__(cr)
        self.notify.setInfo(True)

        self._auth_success_callback = None
        self._auth_failure_callback = None

    def configure_authentication_handlers(self, success: object = None, failure: object = None) -> None:
        """
        Configures our authentication handler callbacks
        """

        self._auth_success_callback = success
        self._auth_failure_callback = failure

    def authenticate_with_email_password(self, email: str, password: str) -> None:
        """
        Signs the user into the Astron cluster using a PlayFab account
        """

        request = {
            'Email': email,
            'Password': password,
            'CreateAccount': True
        }

        self.notify.info('Authenticating with email and password')
        PlayFabClientAPI.LoginWithEmailAddress(request, callback=self.handle_playfab_auth_callback)

    def authenticate_with_custom_id(self, custom_id: str) -> None:
        """
        Signs the user into the Astron server cluster using a custom unique identifier generated by the title.
        """

        request = {
            'CustomId': custom_id,
            'CreateAccount': True
        }

        self.notify.info('Authenticating with custom identification')
        PlayFabClientAPI.LoginWithCustomID(request, callback=self.handle_playfab_auth_callback)

    def handle_playfab_auth_callback(self, result: dict = None, error: dict = None) -> None:
        """
        Handles the authentication request callback from PlayFab and pipes the success ticket through to the
        Astron cluster
        """

        # Check if there was an error from PlayFab. If an error was detected convert that into the standard
        # failure callback format used by the QuestLoginManager system
        if error != None:
            code = error['errorCode']
            reason = error['errorMessage']

            self.handle_request_authentication_result(code, reason)
            return

        # Attempt to authenticate with the Astron cluster using our PlayFab session ticket
        session_token = result['SessionTicket']
        self.d_request_authentication(session_token)
        
    def d_request_authentication(self, token: str) -> None:
        """
        Sends an authentication request to the game server
        """

        self.notify.info('Attempting to retrieve validation from UberDOG')
        self.send_update('request_authentication', [token])

    def handle_request_authentication_result(self, code: int, message: str) -> None:
        """
        Handles the authentication results from the UberDOG server
        """

        self.notify.info('Received authentication validation from UberDOG')
        if code != 200 and self._auth_failure_callback != None:
            self._auth_failure_callback(code, message)
        elif self._auth_success_callback != None:
            self._auth_success_callback()

#----------------------------------------------------------------------------------------------------------------------------------------------------------------------#

class QuestLoginManagerAI(objects.QuestDistributedObjectGlobalAI):
    """
    AI/Shard side DOG instance of the QuestLoginManager used to authenticate with the Astron cluster and gain entry to the game world.
    """

#----------------------------------------------------------------------------------------------------------------------------------------------------------------------#

class QuestLoginManagerUD(objects.QuestDistributedObjectGlobalUD):
    """
    UberDOG side DOG instance of the QuestLoginManager used to authenticate with the Astron cluster and gain entry to the game world.
    """

    # "122" is the magic number for login problems.
    # See https://github.com/Astron/Astron/blob/master/doc/protocol/10-client.md
    ASTRON_CA_INVALID_AUTH_EJECT = 122

    def __init__(self, air: object):
        super().__init__(air)

        self.sender2login_operation = {}
        self.account2operation = {}

    def get_account_connection_channel(self, do_id: int) -> int:
        """
        Retrieves the account connection channel from a distributed object identifer
        """

        return do_id + (1003 << 32)

    def request_authentication(self, token: str) -> None:
        """
        Handles incoming client authentication requests. Attempts to verify their PlayFab session ticket and retrieve account details
        """

        # Verify the sender is not already logged in
        sender = self.air.get_msg_sender()
        if sender >> 32:
            self.air.eject(sender, self.ASTRON_CA_INVALID_AUTH, "Account is already logged in")
            return
        
        # Verify they don't already have an ongoing login operation
        if sender in list(self.sender2login_operation.keys()):
            self.air.eject(sender, self.ASTRON_CA_INVALID_AUTH, "Account is already logging in else where")
            return          

        # Run the login operation for the sender
        login_op = PlayFabLoginOperation(self, sender)
        self.sender2login_operation[sender] = login_op
        login_op.start(token)

    def d_send_authentication_result(self, sender: int, result_code: int, message: str = 'Ok') -> None:
        """
        Sends the authentication result to a client instance
        """
    
        self.sendUpdateToChannel(sender, 'handle_request_authentication_result', [result_code, message])

#----------------------------------------------------------------------------------------------------------------------------------------------------------------------#

class QuestLoginManagerOperation(object):
    """
    Base class for all QuestLoginManager server operations
    """

    def __init__(self, login_manager: QuestLoginManagerUD, sender: object):
        self._login_manager = login_manager
        self._sender = sender
        self._callback = None

    @property
    def login_manager(self) -> QuestLoginManagerUD:
        """
        Returns our login_manager variable instance as a property
        """

        return self._login_manager

    @property
    def sender(self) -> object:
        """
        Returns our sender variable instance as a property
        """

        return self._sender

    @property
    def callback(self) -> object:
        """
        Returns our callback variable instance as a property
        """

        return self._callback

    def set_callback(self, callback: object) -> None:
        """
        Sets our callback variable instance
        """

        return self._callback

    def _handle_done(self) -> None:
        """
        """

        if self.__class__.__name__ == PlayFabLoginOperation.__name__:
            del self.login_manager.sender2login_operation[self.sender]
        else:
            del self.login_manager.account2operation[self.sender]

#----------------------------------------------------------------------------------------------------------------------------------------------------------------------#

class PlayFabLoginOperation(QuestLoginManagerOperation):
    """
    LoginManager operation instance for authentication with PlayFab's servers and unsandboxing the incoming client connection
    """

    # Unique User data key used to query the internal account id from PlayFab's server
    INTERNAL_ACCOUNT_ID = 'InternalAccountId'

    def __init__(self, login_manager: QuestLoginManagerUD, sender: object):
        super().__init__(login_manager, sender)

        self.session_ticket = ''
        self.playfab_id = ''
        self.account_id = 0
        self.account = None

    def start(self, session_ticket: str) -> None:
        """
        Starts the PlayFab authentication operation using the client's session ticket
        """

        self.session_ticket = session_ticket
        self._verify_session_ticket()

    def send_authentication_result(self, result_code: object, message: str = 'success', eject: bool = False) -> None:
        """
        Sends the final authentication result back to the sender client channel
        """

        # Convert internal result code enumerables into their integer value
        if hasattr(result_code, 'value'):
            result_code = result_code.value

        if eject:
            self.air.eject(self.sender, QuestLoginManager.ASTRON_CA_INVALID_AUTH, message)
        else:
            self.login_manager.d_send_authentication_result(self.sender, result_code, message)

    def _verify_session_ticket(self) -> None:
        """
        Attempts to verify a client session ticket with PlayFab
        """

        request = {
            'SessionTicket': self.session_ticket
        }

        PlayFabServerAPI.AuthenticateSessionTicket(request, self._handle_verify_session_ticket_callback)

    def _handle_potential_playfab_error(self, error: dict = None) -> None:
        """
        Handles any potential PlayFab callback errors and pipes them through to the sender
        """

        # Check if there was an error from PlayFab. If an error was detected convert that into the standard
        # failure callback format used by the QuestLoginManager system
        if error != None:
            code = error['errorCode']
            reason = error['errorMessage']

            self.send_authentication_result(code, reason)

    def _handle_verify_session_ticket_callback(self, result: dict, error: dict) -> None:
        """
        Handles AuthenticateSessionTicket callbacks from PlayFab servers.
        """

        # Handle any potential PlayFab errors
        self._handle_potential_playfab_error(error)

        # Query our internal account id from the user's PlayFab account
        self.playfab_id = result['UserInfo']['PlayFabId']
        request = {
            'PlayFabId': self.playfab_id,
            'Keys': [self.INTERNAL_ACCOUNT_ID]
        }
        PlayFabServerAPI.GetUserInternalData(request, self._handle_internal_account_lookup_callback)

    def _handle_internal_account_lookup_callback(self, result: dict, error: dict) -> None:
        """
        Handles the internal account id lookup callback from PlayFab's servers
        """

        # Handle any potential PlayFab errors
        self._handle_potential_playfab_error(error)

        # Check if the user has an internal account id
        user_data = result['Data']
        if self.INTERNAL_ACCOUNT_ID in user_data:
            self.account_id = int(user_data[self.INTERNAL_ACCOUNT_ID]['Value'])
            self._handle_retrieve_account()
        else:
            self._handle_create_account()

    def _handle_retrieve_account(self) -> None:
        """
        Attempts to retrieve the user's internal account from Astron's database instance.
        """

        self.login_manager.air.dbInterface.queryObject(
            self.login_manager.air.db_server_channel, self.account_id, self._handle_account_retrieved)

    def _handle_account_retrieved(self, dclass: object, fields: object) -> None:
        """
        Handles the callback from Astron's database retrieving their account information
        """

        assert dclass == self.login_manager.air.dclassesByName[QuestAccountUD.__name__], 'Received an invalid account dclass type'
        self.account = fields
        self._handle_set_account()

    def _handle_create_account(self) -> None:
        """
        Creates a new internal account for the incoming client and associates it with their PlayFab account
        """

        account_inst = QuestAccountUD(self.playfab_id)
        self.account = dataclasses.asdict(account_inst)

        self.login_manager.air.dbInterface.createObject(
            self.login_manager.air.db_server_channel,
            self.login_manager.air.dclassesByName[QuestAccountUD.__name__],
            self.account,
            self._handle_account_created)

    def _handle_account_created(self, account_id: int) -> None:
        """
        Handles the callback from the Astron database interface and stores the new internal account id to the player's
        PlayFab account instance
        """

        if not account_id:
            self.send_authentication_result(
                result_code=QuestInternalAuthResults.QIAR_INTERNAL_ERROR, 
                message='An internal error has occured') #TODO: localize properly
            
            return

        self.account_id = account_id

        request = {
            'PlayFabId': self.playfab_id,
            'Data': {
                self.INTERNAL_ACCOUNT_ID: self.account_id
            }
        }

        PlayFabServerAPI.UpdateUserInternalData(request, self._handle_account_id_stored_callback)

    def _handle_account_id_stored_callback(self, result: dict, error: dict) -> None:
        """
        Handles the confirmation from PlayFab that the internal account id was stored succesfully and 
        sets the client's account details
        """

        # Handle any potential PlayFab errors and set our account information for the client
        self._handle_potential_playfab_error(error)
        self._handle_set_account()

    def _handle_set_account(self) -> None:
        """
        """

        # Disconnect anyone else that may already be on this account channel
        account_channel = self.login_manager.get_account_connection_channel(self.account_id)
        self.login_manager.air.eject(account_channel, QuestLoginManagerUD.ASTRON_CA_INVALID_AUTH_EJECT, 'Someone else logged in with this account else where.') #TODO: localize properly

        # Add our account connection channel to the client
        datagram = PyDatagram()
        datagram.addServerHeader(self.sender, self.login_manager.air.ourChannel, MsgTypes.CLIENTAGENT_OPEN_CHANNEL)
        datagram.addChannel(account_channel)
        self.login_manager.air.send(datagram)

        # Set sender channel to represent account affiliation
        datagram = PyDatagram()
        datagram.addServerHeader(self.sender, self.login_manager.air.ourChannel, MsgTypes.CLIENTAGENT_SET_CLIENT_ID)
        datagram.addChannel(self.account_id << 32)  # account Id is in high 32 bits, 0 in low (no avatar).
        self.login_manager.air.send(datagram)

        # Set our new client's connection state as established
        self.login_manager.air.setClientState(self.sender, 2)

        # Send our final authentication result
        self.send_authentication_result(result_code=QuestInternalAuthResults.QIAR_SUCCESS) 

        # Add client interest to our root game distributed object id zones
        self.login_manager.air.client_add_interest_multiple(self.sender, 0, self.login_manager.air.getGameDoId(), constants.STARTING_NETWORK_ZONES)

#----------------------------------------------------------------------------------------------------------------------------------------------------------------------#
