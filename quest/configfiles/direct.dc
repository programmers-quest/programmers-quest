// This is a sample dc file for some of the classes defined within the
// direct source tree.  It is suggested that you copy this file into
// your own project (or load it from the direct source tree) and build
// on it with your own dc file for your own classes.

keyword broadcast;
keyword ram;
keyword p2p;

from direct.distributed import DistributedObject/AI/UD
from direct.distributed import DistributedObjectGlobal/AI/UD
from direct.distributed import DistributedNode/AI/UD
from direct.distributed import DistributedSmoothNode/AI
from direct.distributed import DistributedObject/AI/UD
from direct.distributed import DistributedCartesianGrid/AI
from direct.distributed import DistributedCamera/AI/OV
from direct.distributed import TimeManager/AI

struct BarrierData {
    uint16 context;
    string name;
    uint32 avIds[];
};

// The most fundamental class
dclass DistributedObject {
    // These are used to support DistributedObjectAI.beginBarrier() and
    // the matching DistributedObject.doneBarrier().  If you don't call
    // these functions, you don't care about these distributed methods.
    // (Actually, you probably don't care anyway.)
    setBarrierData(BarrierData data[]) broadcast ram;
    setBarrierReady(uint16 context);
    setLocation(uint32 parentId, uint32 zoneId) broadcast ram;
};

dclass DistributedObjectGlobal : DistributedObject {
};

dclass TimeManager: DistributedObject {
  requestServerTime(uint8 context) clsend;
  serverTime(uint8 context, int32 timestamp);
};

dclass DistributedNode: DistributedObject {
    setX(int16 / 10) broadcast ram;
    setY(int16 / 10) broadcast ram;
    setZ(int16 / 10) broadcast ram;
    setH(int16 % 360 / 10) broadcast ram;
    setP(int16 % 360 / 10) broadcast ram;
    setR(int16 % 360 / 10) broadcast ram;

    setPos: setX, setY, setZ;
    setHpr: setH, setP, setR;
    setPosHpr: setX, setY, setZ, setH, setP, setR;
    setXY: setX, setY;
    setXZ: setX, setZ;
    setXYH: setX, setY, setH;
    setXYZH: setX, setY, setZ, setH;
};


dclass DistributedSmoothNode: DistributedNode {
  // Component set pos and hpr functions.

  setComponentL(uint64) broadcast ram;
  setComponentX(int16 / 10) broadcast ram;
  setComponentY(int16 / 10) broadcast ram;
  setComponentZ(int16 / 10) broadcast ram;
  setComponentH(int16 % 360 / 10) broadcast ram;
  setComponentP(int16 % 360 / 10) broadcast ram;
  setComponentR(int16 % 360 / 10) broadcast ram;
  setComponentT(int16 timestamp) broadcast ram;

  // Composite set pos and hpr functions.  These map to combinations
  // of one or more of the above components.  They all include
  // setComponentT(), which must be called last.
  setSmStop: setComponentT;
  setSmH: setComponentH, setComponentT;
  setSmZ: setComponentZ, setComponentT;
  setSmXY: setComponentX, setComponentY, setComponentT;
  setSmXZ: setComponentX, setComponentZ, setComponentT;
  setSmPos: setComponentX, setComponentY, setComponentZ, setComponentT;
  setSmHpr: setComponentH, setComponentP, setComponentR, setComponentT;
  setSmXYH: setComponentX, setComponentY, setComponentH, setComponentT;
  setSmXYZH: setComponentX, setComponentY, setComponentZ, setComponentH, setComponentT;
  setSmPosHpr: setComponentX, setComponentY, setComponentZ, setComponentH, setComponentP, setComponentR, setComponentT;
  // special update if L (being location, such as zoneId) changes, send everything, intended to
  // keep position and 'location' in sync
  setSmPosHprL: setComponentL, setComponentX, setComponentY, setComponentZ, setComponentH, setComponentP, setComponentR, setComponentT;

  clearSmoothing(int8 bogus) broadcast;

  suggestResync(uint32 avId, int16 timestampA, int16 timestampB,
                int32 serverTimeSec, uint16 serverTimeUSec,
                uint16 / 100 uncertainty);
  returnResync(uint32 avId, int16 timestampB,
               int32 serverTimeSec, uint16 serverTimeUSec,
               uint16 / 100 uncertainty);
}; 

dclass DistributedCartesianGrid: DistributedNode {
    // Make sure setCellWidth gets called before setParentingRules
    setCellWidth(uint32 width) required broadcast ram;

    // base:size:resolution
    //.. 0:100:1 == 3x3  interest grids.. with 100x100 size.. numbering starting at 0 ie 0.0 = 0
    setParentingRules(string type="Cartesian", string Rule="0:100:1") broadcast ram;
};

struct Fixture {
    int32  / 10;
    int32  / 10;
    int32  / 10;
    int16  / 10;
    int16  / 10;
    int16  / 10;
    string = "Standby";
};

dclass DistributedCamera: DistributedNode {
    setCamParent(uint32 doId = 0) required broadcast ram ownsend airecv;
    setFixtures(Fixture[]) required broadcast ram ownsend airecv;
};